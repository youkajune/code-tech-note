---
lang: zh-CN
title: 函数探幽
description: 函数
categories:
 - C语言
tags:
 - C语言
---

## 初识函数

### 什么是函数？

**函数是完成特定任务的独立程序代码单元，也是 C 程序的基本组成单位**。语法规则定义了函数的结构和使用方式 —— 函数定义和函数调用。虽然 C 中的函数和其他语言中的函数、子程序、过程作用相同，但是细节上略有不同。

一些函数执行某些动作，如 printf() 把数据打印到屏幕上；一些函数找出一个值供程序使用，如 strlen() 把指定字符串的长度返回给程序。一般而言，函数可以同时具备以上两种功能。

### 为什么用函数？

首先，使用函数可以省去编写重复代码的苦差。如果程序要多次完成某项任务，那么只需编写一个合适的函数，就可以在需要时使用这个函数，或者在不同的程序中使用该函数，就像许多程序中使用 putchar() 一样。其次，即使程序只完成某项任务一次，也值得使用函数。因为函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、完善。

例如，假设要编写一个程序完成以下任务：读入一系列数字、分类这些数字、找出这些数字的平均值、打印一份柱状图。可以使用下面的程序：

```c
#include <stdio.h> 
#define SIZE 50 
int main(void) 
{
    float list[SIZE]; 
    readlist(list, SIZE); 
    sort(list, SIZE); 
    average(list, SIZE); 
    bargraph(list, SIZE); 
    return 0; 
}
```

当然，还要编写 4 个函数 readlist()、sort()、average() 和 bargraph() 的实现细节。描述性的函数名能清楚地表达函数的用途和组织结构。然后，单独设计和测试每个函数，直到函数都能正常完成任务。如果这些函数够通用，还可以用于其他程序。

许多程序员喜欢把函数看作是根据传入信息(输入)及其生成的值或响应的动作(输出)来定义的“黑盒”。如果不是自己编写函数，根本不用关心黑盒的内部行为。例如，使用 printf() 时，只需知道给该函数传入格式字符串或一些参数以及 printf() 生成的输出，无需了解 printf() 的内部代码。以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上。因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务，以及函数和程序整体的关系。

### 如何学习函数？

函数这部分主要的知识点有三部分 —— 如何定义函数、调用函数以及函数间的通信，除此之外，还需要了解参数传递、递归、变参函数几个小知识点。先演示一个简单的例子：

```c
#include <stdio.h> 
#define NAME "GIGATHINK, INC." 
#define ADDRESS "101 Megabuck Plaza" 
#define PLACE "Megapolis, CA 94904" 
#define WIDTH 40 
void starbar(void); /* 函数原型 */ 
int main(void) 
{
    starbar(); 
    printf("%s\n", NAME); 
    printf("%s\n", ADDRESS); 
    printf("%s\n", PLACE); 
    starbar(); /* 使用函数 */ 
    return 0; 
}
void starbar(void) /* 定义函数 */ 
{
    int count; 
    for (count = 1; count <= WIDTH; count++) 
        putchar('*'); 
    putchar('\n'); 
}
```

该程序的输出如下：

```plain
****************************************
GIGATHINK, INC. 
101 Megabuck Plaza 
Megapolis, CA 94904 
****************************************
```

该程序要注意以下几点。程序在 3 处使用了 starbar 标识符：1. 函数原型告诉编译器函数 starbar() 的类型；2. 函数调用表明在此处执行函数；3. 函数定义明确地指定了函数要做什么。

## 定义函数

函数和变量类似，例如，变量需要先定义之后才能使用 —— 函数也需要先定义之后才能使用；变量有不同的类型 —— 函数也有类型；通过变量名来使用变量 —— 函数调用需要使用函数名。

定义一个函数有两种方式，一种是直接使用函数定义；另一种是先使用函数声明告诉编译器函数要如何使用，再使用函数定义规定函数的执行细节。

### 函数定义

**函数定义**：指对函数功能的确立，包括指定函数名，函数值类型、形参类型、函数体等，它是一个完整的、独立的函数单位。

函数定义的格式：

```c
返回值类型 函数名(参数列表)
{
    // 函数体
    return 返回值;
}
```

示例：

```c
#include <stdio.h>
// 函数定义
int add(int a, int b) {
    int c = a + b;
    return c;
}
int main() {
    // 调用函数
}
```

### 函数声明

C 语言代码由上到下依次执行，原则上函数定义要出现在函数调用之前，否则就会报错。但在实际开发中，经常会在函数定义之前使用它们，这个时候就需要提前声明。

**函数声明**：把函数的名字、函数类型以及形参类型、个数和顺序通知编译系统，以便在调用该函数时系统按此进行对照检查。

所谓**函数声明**，就是告诉编译器我要使用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后我会把定义补上。

> PS：对于一些老旧的编译器来说，函数声明是不带参数列表的。

函数声明给出了函数名、返回值类型、参数列表（重点是参数类型）等与该函数有关的信息，也称为**函数原型**、函数头。简单来说，就是将函数定义的函数体替换为分号。

```c
// 函数声明，也称为函数原型
返回值类型 函数名(参数列表);
// 示例：
int add(int a, int b);
```

**函数原型相当于函数声明**。需要注意的是，虽然现在一般都会说函数原型就是函数声明，但其实对于一些老旧的编译器，它们是不同的，对于这些老旧的编译器，函数声明是不带参数列表的，如`int imax();`，但是这样编译器无法针对参数不匹配的问题，因此提出了函数原型来解决这个问题，因此在后来的编译器中函数声明的标准中加上了参数列表。

函数原型的作用是告诉编译器该函数有关的信息，让编译器知道函数的存在，以及存在的形式，即使函数暂时没有定义，编译器也知道如何使用它。这样在有函数声明的情况下，函数定义就可以出现在任何地方了，甚至是其他文件、静态链接库、动态链接库等。

> 注意：函数声明并不可以代替函数定义，函数声明的意义在于可以使得函数定义出现在函数调用之后或者出现在其他文件中。

**Q：已经有了函数定义，为什么还需要函数声明？**

**A**：如果没有函数声明，函数定义必须在函数调用之前，否则会报错。例如，下面的例子就会报错，错误提示是 add 函数没有定义：

```c
#include <stdio.h>
int main() {
    // 调用函数
    int c = add(3, 4);// 报错
}
// 函数定义
int add(int a, int b) {
    int c = a + b;
    return c;
}
```

这时在函数调用之前加上函数声明，就不会报错了。

```c
#include <stdio.h>
int add(int a, int b);
int main() {
    // 调用函数
    int c = add(3, 4);// 正确
}
// 函数定义
int add(int a, int b) {
    int c = a + b;
    return c;
}
```

函数声明的参数列表中的参数名可以和函数定义的参数列表中的参数名不同。

> PS：C 语言函数声明中的参数列表可以省略，C++函数声明的参数列表不可省略，因为C++会存在函数重载的问题，需要参数列表作为特征标。

### 函数的类型

函数和变量一样，有多种类型。任何程序在使用函数之前都要声明该函数的类型。

**函数类型**：函数类型取决于函数的返回值以及参数的类型。返回值类型和参数类型相同的函数是同一种类型的函数。例如上面的程序中，函数原型部分 `void starbar(void);` 其中第一个 void 是函数类型，void 类型表明 starbar() 函数无返回值类型。

> PS：如果不声明返回值类型，C 语言默认是返回 int 类型。

上面关于函数类型的定义是来自书上的，我其实不太认同。我认为返回值类型以及参数列表两者共同表示了函数的类型。根据指针来证明：

```c
#include <stdio.h>
int f1(int a, int b);
int main(void) {
	int (*ptr)(int a) = f1; // 会报错
}
int f1(int a, int b) {
    return a+b;
}
```

如果函数返回值类型就是函数类型的话，函数指针就没有必要要求指针的参数列表也要和指向的函数的参数列表一致了。

我对这里说的函数类型是返回值类型的理解是：C语言不支持函数重载，而且C语言可以在函数声明中不写参数列表，只在函数定义中提供参数列表。

## 递归

### 什么递归？

**C 语言允许函数调用自己，这种函数自己调用自己的过程称为递归(recursion)。**

我们来看一个简单的递归示例 —— 计算阶乘的函数，并计算 0~9 的阶乘值。

```c
#include<stdio.h>
int factorial(int);
int main()
{
    int n = 10;
    for (int i = 0; i < n; i++)
        printf("(%d!) = %d\n", i, factorial(i));
    
    getchar();
    return 0;
}
int factorial(int a)
{
    if (a < 2)
        return 1;
    return factorial(a - 1) * a;
}
```

<img src="E:\Note\Code Language\the-c\picture\basic\4-1.png" align="left" />

递归有时难以捉摸，有时却很方便实用。**结束递归是使用递归的难点**，因为如果递归代码中没有终止递归的条件测试部分，一个调用自己的函数会无限递归。

可以使用循环的地方通常都可以使用递归。有时用循环解决问题比较好，但有时用递归更好。**递归方案更简洁，但效率却没有循环高**。

### 递归的基本原理

初次接触递归会觉得比较难以理解，为了帮助大家理解递归过程，讲解几个递归的要点。

1. **每级函数调用都有自己的变量。**
2. **每次函数调用都会返回一次。当函数执行完毕后，控制权将被传回上一级递归。程序必须按顺序逐级返回递归。**
3. **递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。**
4. **递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。**
5. **虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代码。除了为每次递归调用创建变量外，递归调用非常类似于一个循环语句。实际上，递归有时可用循环来代替，循环有时也能用递归来代替。** 
6. **递归函数必须包含能让递归调用停止的语句。通常，递归函数都使用if或其他等价的测试条件在函数形参等于某特定值时终止递归。为此，每次递归调用的形参都要使用不同的值。**

为了方便演示上面的几个要点，在阶乘函数中加入了一些输出信息。

```c
#include<stdio.h>
int factorial(int);
int main()
{
    printf("main: (4!) = %d\n", factorial(4));
    return 0;
}
int factorial(int a)
{
    printf("start: a = %d, &a = %p\n", a, &a);
    if (a < 2) {
        printf("end: a = %d, &a = %p\n", a, &a);
        return 1;
    }
    int result = factorial(a - 1) * a;
    printf("end: a = %d, &a = %p\n", a, &a);
    return result;
}
```

<img src="E:\Note\Code Language\the-c\picture\basic\4-2.png" align="left" />

可以看到计算 4 的阶乘的时候有四级调用，第一级调用是 factorial(4)，第二级调用是 factorial(3) ...。每一级调用中的形式参数 a 都是不同的，这一点可以通过它们的地址来看出来。递归调用之前的输出信息语句是按照递归调用的顺序输出的(4 3 2 1)，而递归调用之后的输出信息语句是逆序的(1 2 3 4)。

### 尾递归

最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句之前。这种形式的递归被称为尾递归(tail recursion)，因为递归调用在函数的末尾。**尾递归是最简单的递归形式，因为它相当于循环**。我们前面的计算阶乘的函数就是尾递归。



**既然用递归和循环来计算阶乘都没问题，那么到底应该使用哪一个？**

一般而言，选择循环比较好。首先，每次递归都会创建一组变量，所以**递归使用的内存**更多，而且每次递归调用都会把创建的一组新变量放在栈中。**递归调用的数量受限于内存空间**。其次，由于每次**函数调用要花费一定的时间，所以递归的执行速度较慢**。



**既然递归执行速度较慢，为什么还要学习递归？**

尾递归是递归中最简单的形式，比较容易理解。**在某些情况下，不能用简单的循环代替递归**，因此读者还是要好好理解递归。

### 倒序计算

递归在处理倒序时非常方便（在解决这类问题中，递归比循环简单）。

例如，编写一个函数，输入一个整数，打印这个整数的二进制数。

```c
#include<stdio.h>
void binary(int);
int main()
{
    int a;
    scanf("%d", &a);
    binary(a);
    return 0;
}
void binary(int a)
{
    if(a/2)
        binary(a/2);
    printf("%d", a%2);
}
```

<img src="E:\Note\Code Language\the-c\picture\basic\4-3.png" align="left" />

**不用递归，是否能实现这种用二进制形式表示整数的算法？**

当然可以。 但是由于这种算法要首先计算最后一位二进制数，所以在显示结果之前必须把所有的位数都储存在别处（例如，数组）。

### 递归的优缺点

递归既有优点也有缺点。

**优点**：递归为某些编程问题提供了最简单的解决方案。

**缺点**：一些递归算法会快速消耗计算机的内存资源。另外，递归不方便阅读和维护。



我们再来举一个典型的例子，斐波那契数列。斐波那契数列的定义如下：第1 个数字和第 2 个数字都是 1，而后续的每个数字都是其前两个数字之和。例如，该数列的前几个数是：1、1、2、3、5、8、13。用数学上的数列来描述的话就是：

![img](E:\Note\Code Language\the-c\picture\basic\4-4.svg)

首先，我们来看看递归的实现。递归提供一个简单的定义。如果把函数命名为 Fibonacci()，那么如果 n 是 1 或 2， Fibonacci(n) 应返回 1，对于其他数值，则应返回 Fibonacci(n-1) + Fibonacci(n-2)。代码如下：

```c
unsigned long Fibonacci(unsigned n) 
{
    if (n < 3) 
   		return 1; 
    return Fibonacci(n-1) + Fibonacci(n-2);
}
```

这个递归函数只是重述了数学定义的递归。该函数使用了双递归(double recursion)，即函数每一级递归都要调用本身两次，这就造成了一个问题。

为了说明这个问题，假设调用 Fibonacci(40)。这是第 1 级递归调用，将创建一个变量 n。然后在该函数中要调用 Fibonacci() 两次，在第 2 级递归中要分别创建两个变量 n。这两次调用中的每次调用又会进行两次调用，因而在第 3 级递归中要创建 4 个名为 n 的变量。此时总共创建了 7 个变量。由于每级递归创建的变量都是上一级递归的两倍，所以**变量的数量呈指数增长！**按指数增长很快就会产生非常大的值。在本例中，指数增长的变量数量很快就消耗掉计算机的大量内存，很可能导致程序崩溃。 

虽然这是个极端的例子，但是该例说明：**在程序中使用递归要特别注意，尤其是效率优先的程序**。



所有的 **C** 函数皆平等。程序中的每个 C 函数与其他函数都是平等的。每个函数都可以调用其他函数，或被其他函数调用。这点与 Pascal 和 Modula-2 中的过程不同，虽然过程可以嵌套在另一个过程中，但是嵌套在不同过程中的过程之间不能相互调用。 

main() 函数是否与其他函数不同？是的，main() 的确有点特殊。当 main() 与程序中的其他函数放在一起时，最开始执行的是 main() 函数中的第 1 条语句，但是这也是局限之处。main() 也可以被自己或其他函数递归调用 —— 尽管很少这样做。

## 变参函数

stdarg.h 头文件为函数提供了变参函数的功能，但是用法比较复杂。必须按如下步骤进行：

1. 提供一个使用省略号的函数原型； 
2. 在函数定义中创建一个 va_list 类型的变量； 
3. 用宏把该变量初始化为一个参数列表； 
4. 用宏访问参数列表； 
5. 用宏完成清理工作。 

变参函数的实现其实离不开变参宏，接下来详细分析这些步骤。这种函数的原型应该有一个形参列表，其中**至少有一个形参和一个省略号**：

```c
void f1(int n, ...); // 有效 
int f2(const char * s, int k, ...); // 有效 
char f3(char c1, ..., char c2);// 无效，省略号不在最后 
double f3(...); // 无效，没有形参 
```

最右边的形参（即省略号的前一个形参）起着特殊的作用，标准中用 parmN 这个术语来描述该形参。在上面的例子中，第1行f1()中 parmN 为 n，第2行 f2() 中 parmN 为 k。传递给该形参的实际参数是省略号部分代表的参数数量。例如，可以这样使用前面声明的 f1() 函数： 

```c
f1(2, 200, 400); // 2个额外的参数 
f1(4, 13, 117, 18, 23); // 4个额外的参数
```

接下来，声明在 stdarg.h 中的 va_list 类型代表一种用于储存形参对应的形参列表中省略号部分的数据对象。变参函数的定义起始部分类似下面这样：

```c
double sum(int lim,...) 
{
	va_list ap; //声明一个储存参数的对象 
```

在该例中，lim 是 parmN 形参，它表明变参列表中参数的数量。然后，该函数将使用定义在 stdarg.h 中的 va_start() 宏，把参数列表拷贝到 va_list 类型的变量中。该宏有两个参数：va_list 类型的变量和 parmN 形参。

接着上面的例子讨论，va_list 类型的变量是 ap，parmN 形参是 lim。所以，应这样调用它： 

```c
va_start(ap, lim); // 把ap初始化为参数列表 
```

下一步是访问参数列表的内容，这涉及使用另一个宏 va_arg()。该宏接受两个参数：一个 va_list 类型的变量和一个类型名。第1次调用 va_arg() 时，它返回参数列表的第1项；第2次调用时返回第2项，以此类推。表示类型的参数指定了返回值的类型。例如，如果参数列表中的第1个参数是 double 类型，第2个参数是 int 类型，可以这样做： 

```c
double tic; 
int toc; 
... 
tic = va_arg(ap, double); // 检索第1个参数 
toc = va_arg(ap, int); //检索第2个参数 
```

注意，**传入的参数类型必须与宏参数的类型相匹配**。如果第1个参数是10.0，上面 tic 那行代码可以正常工作。但是如果参数是10，这行代码可能会出错。这里不会像赋值那样把 double 类型自动转换成 int 类型。 

最后，要使用 va_end() 宏完成清理工作。例如，释放动态分配用于储存参数的内存。该宏接受一个 va_list 类型的变量： `va_end(ap); // 清理工作`

调用 va_end(ap) 后，只有用 va_start 重新初始化 ap 后，才能使用变量 ap。因为 va_arg() 不提供退回之前参数的方法，所以有必要保存 va_list 类型变量的副本。C99 新增了一个宏用于处理这种情况：va_copy()。该宏接受两个 va_list 类型的变量作为参数，它把第2个参数拷贝给第1个参数：

```c
va_list ap; 
va_list apcopy; 
double 
double tic; 
int toc; 
... 
va_start(ap, lim); // 把ap初始化为一个参数列表 
va_copy(apcopy, ap); // 把apcopy作为ap的副本 
tic = va_arg(ap, double); // 检索第1个参数 
toc = va_arg(ap, int); // 检索第2个参数 
```

此时，即使删除了 ap，也可以从 apcopy 中检索两个参数。 

```c
//varargs.c -- use variable number of arguments 
#include <stdio.h> 
#include <stdarg.h> 
double sum(int, ...); 
int main(void) 
{
    double s, t; 
    s = sum(3, 1.1, 2.5, 13.3); 
    t = sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1); 
    printf("return value for sum(3, 1.1, 2.5, 13.3): %g\n", s); 
    printf("return value for sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1): %g\n", t); 
    return 0; 
}
double sum(int lim, ...) 
{
    va_list ap; // 声明一个对象储存参数 
    double tot = 0; 
    int i; 
    va_start(ap, lim); // 把ap初始化为参数列表 
    for (i = 0; i < lim; i++) 
    tot += va_arg(ap, double); // 访问参数列表中的每一项 
    va_end(ap); // 清理工作 
    return tot; 
}   
```

下面是该程序的输出： 

```c
return value for sum(3, 1.1, 2.5, 13.3): 16.9 
return value for sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1): 31.6 
```

查看程序中的运算可以发现，第1次调用 sum() 时对3个数求和，第2次调用时对6个数求和。总而言之，使用变参函数比使用变参宏更复杂，但是函数的应用范围更广。
