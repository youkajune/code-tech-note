---
lang: zh-CN
title: 指针
description: 指针
categories:
 - C语言
tags:
 - C语言
---

## 什么是指针？

### 内存

指针会涉及到内存地址，因此在指针之前先了解下内存的相关知识。

外存就是我们常用的硬盘(C盘、D盘等)、U 盘、光盘等。外存存储的数据量大，但是处理数据的速度慢，而 CPU 的运行速度是非常快的，为了提高效率，就出现了内存，内存存储的数据量小(目前常见的是 8 G)，但是处理数据的速度快，**CPU 处理的数据都在内存中**。

**内存和外存的区别**：

1. **内存存储的数据量远小于外存**。目前个人电脑内存比较常见的是 8G 和 16G，而硬盘常见的应该是 300G 左右吧，U 盘基本上也是 32G 左右的比较常用。
2. **内存速度比外存的速度快**。这也是使用内存的原因，外存处理数据速度太慢，而内存的速度则比外存快的太多了，因此使用内存来和 CPU 进行数据的交互。
3. **内存的成本大于外存**。要是内存成本 <= 外存成本，那么直接就是全用内存作为存储设备了，还分啥内外存呢。
4. **内存存储数据的时间小于外存**。内存存储的数据在断电之后会消失，而外存会一直存储。

> 为了进一步提高效率，在内存和 CPU 之间还会有缓存。缓存的存储量更小，速度更快。

我们编写的程序(代码)在不执行的时候，以文件的形式存储在外存中。而当我们执行程序时，程序就会被调入到内存中(程序在执行之后称为进程)。在编写 C 语言程序时，我们写的变量、函数等等，都是会在程序执行之后放入到内存中，以供 CPU 使用。而 CPU 只能通过地址来获取内存中的代码和数据，程序在执行过程中会告知 CPU 要执行的代码以及要读写的数据的地址。

CPU 访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，是为我们提供方便的，让我们在编写代码的过程中可以使用易于阅读和理解的英文字符串，不用直接面对二进制地址。当源文件被编译和链接成可执行程序后，它们都会被替换成地址。编译和链接过程的一项重要任务就是找到这些名称所对应的地址。

### 指针概念介绍

**从根本上看，****指针是一个****值为内存地址的****变量**(或数据对象)。正如 char 类型变量的值是字符，int 类型变量的值是整数，**指针变量的值是地址**。

事实上，我们的程序中的变量名、函数名、指针在本质上是一样的，它们都是**地址助记符**。但在编写代码的过程中，我们认为变量名表示的是数据本身，而函数名、指针表示的是代码块或数据块的首地址。

## 为什么学习指针？

1. 指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。
2. 指针的大小是固定的，在 32 位系统中占 4 字节，在 64 位系统中占 8 字节。在面对普通的数据类型时，我们可能不觉得有什么，但是在学习过结构体之后，函数间传递结构体一般都是用函数体指针，而不是传递结构体的值，因为这样可以节省很大的内存开支。

## 声明指针变量

### 语法

定义指针变量与定义普通变量非常类似，不过要在变量名前面加星号*，格式为：

```cpp
// 声明指针变量
变量类型* 变量名;

// 声明并初始化指针变量
变量类型* 变量名 = 地址值;
```

示例：

```cpp
// 声明指针变量
double* p; // p 是指向 double 类型的指针
// 声明并初始化指针变量
int a = 10;
int* q = &a; // q 是指向 int 类型的指针
```

> 运算符* 在这里的含义是指针，运算符& 在这里的含义是取地址符。

**声明指针变量时必须指定指针所指向变量的类型**。首先，指针只保存数据的首地址，而不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。其次，程序必须知道储存在指定地址上的数据类型，long 和 float 可能占用相同的存储空间，但是它们储存数字却大相径庭。

类型说明符表明了指针所指向对象的类型，星号（*）表明声明的变量是一个指针。

![](E:\Note\Code Language\the-c\picture\basic\5-4.png)

### 地址运算符

在指针中常用的两个地址运算符 —— & 和 *。

**& 运算符**，也称取址运算符，后面跟变量名，给出该变量的地址。

**\*  运算符**，也称解引用运算符，后面跟指针名(或地址)，给出存储在指针指向的地址上的值。

## 指针的初始化

普通变量可以初始化，`type name=value;`。同样的，指针变量也可以初始化，初始化的值是一个地址值。可以借助 & 运算符将某个变量的地址赋值给指针。

```c
int a = 5;
int* ptr = &a; // ptr指针指向a
```

也可以将指针变量赋值给另一个指针变量。

```c
int a = 5;
int* ptr1 = &a; // ptr1指针指向a
int* ptr2 = ptr1;
```

**注意**，将普通变量赋值给指针时，需要在普通变量前面加 & 运算符，因为指针的值是地址，所以用 & 获取普通变量的地址，并赋值给指针变量。而指针变量给指针变量赋值时，直接赋值即可，不需要用 & 运算符。

将普通变量的地址赋值给指针变量的过程也称作指针指向变量。

对于二维指针来说，一维指针相当于普通变量：

```c
int a = 5;
int* ptr1 = &a;
int** ptr2 = &ptr1;
```

## 指针的使用

指针变量的值是地址，但我们往往需要使用的是指针指向的数据，这是就需要用到 * 运算符。

```c
int a = 5;
int* ptr = &a;
// *ptr 是 5
```

### 数组的指针表示法

**在 C 语言中** **ar[i] 和 \*(ar+i) 是等价的，无论 ar 是数组还是指针变量**。但只有当 ar 是指针变量时，才能对 ar 值进行修改，如 ar++。

指针表示法（尤其与递增运算符一起使用时）更接近机器语言，因此一些编译器在编译时能生成效率更高的代码。还记得我们在学习数组时提到的指针表示法吗？指针表示法就是将数组当成指针变量来访问数组元素。

```c
int arr[6] = {1, 4, 3, 6, 1, 8};
// arr[0] 等价于 *(arr + 0) 或 *(arr)
// arr[1] 等价于 *(arr + 1)
// arr[2] 等价于 *(arr + 2)
```

对于多维数组也可以使用指针表示法：

```c
int arr[3][4] = {{1,3,4},{1,2,3,3},{4,5}};
// arr[0][3] 等价于 *(*(arr)+3)
// arr[1][2] 等价于 *(*(arr+1)+2)
```

### 指针运算

指针可以的运算有六种，分别是赋值、解引用、取址、加法、减法、比较。

> PS：指针变量没有乘除法运算，且两个指针相加是没有意义的。

1. **赋值**：**可以将地址赋值给指针。** 例如，用数组名、带地址运算符（&）的 变量名、另一个指针进行赋值。

2. **解引用**：**\* 运算符给出指针指向地址上储存的值。**

3. **取址**：**和所有变量一样，指针变量也有自己的地址和值。** 对指针而言， &运算符给出指针本身的地址。

4. **加法**：指针和整数相加；指针递增。

5. **减法**：指针和整数相减；指针递减；指针和指针相减。通过计算求出两元素之间的距离，通常用于求同一个数组中两个元素的距离。

6. **比较**：**使用关系运算符可以比较两个指针的值**，前提是两个指针都指向相同类型的对象。

   > 千万不要解引用未初始化的指针！！！可能会导致极其严重的错误 —— 可能会擦写数据或代码，或者导致程序崩溃

## 指针数组和数组指针

刚开始接触指针的小白，可能碰到一些复杂点的指针类型就懵逼了，包括比较经典的指针常量和常量指针、指针数组和数组指针的辨析，例如：

```c
int *p[5];
int (*p)[5];
```

### 什么是指针数组和数组指针？

**指针数组**：数组元素是指针的数组。**数组指针**：指向一个数组的指针。

> 记忆的小技巧：和常量指针以及指针常量的记忆类似，记住数组元素是指针和指向一个数组的指针这两句话，将**指针数组**当作数组元素是**指针**的**数组**的缩写，**数组指针**记作指向一个**数组**的**指针**的缩写。

以什么结尾主体就是什么。例如，指针数组是一个数组，什么样的数组？数组元素是指针的数组；数组指针是一个指针，什么样的指针？指向一个数组的指针。

### 如何声明指针数组以及数组指针？

了解了指针数组和数组指针的概念，下面我们来学习如何声明指针数组和数组指针。在指针数组和数组指针这里最重要的一个知识点是 \* 和 [] 运算符的优先级。

![](E:\Note\Code Language\the-c\picture\basic\5-5.png)

可以看到，\* 运算符优先级低于 [] 运算符。

```c
int *ptr[10];
```

因此，在上面的代码中 [] 运算符优先和 ptr 结合，**说明 ptr 是一个数组**。然后 * 运算符结合，说明 ptr 数组的元素是一个指针。再和 int 结合，**说明 ptr 数组元素是一个 int 类型的指针**。因此 ptr 是一个含有十个数组元素的数组，数组元素是 int 类型的指针，即 ptr 是一个指针数组。

我们在来看一个例子：

```c
int (*ptr)[10];
```

在上面的代码中，() 运算符优先级最高，需要先看 () 里面的内容。\* 优先和 ptr 结合，**说明 ptr 是一个指针**。然后 [] 运算符结合，说明 ptr 指向的内容是一个数组。再和 int 结合，说明 ptr 指向的数组的元素是 int 类型的。因此 ptr 是一个指向含有 10 个数组元素数组的指针，数组的元素是 int 类型的，即 ptr 是一个数组指针。



总结：**如何区分数组指针和指针数组的定义？**从变量名处起，根据运算符优先级结合，一步一步分析。

> PS：对于复杂类型的变量也是这样看的。

## 指针常量和常量指针

### 什么是指针常量和常量指针？

**指针常量**：**指针是一个常量**。**特点**：指针的值不能修改，因为指针是一个常量，但是指针指向的值可以改变。

**常量指针**：**指向常量的指针**。顾名思义，指针指向的是一个常量。**特点**：指针的值可以修改，但是指针指向的值不可以修改，因为指针指向的是一个常量。

> 记忆的小技巧：记住指针是一个常量和指向常量的指针这两句话，把**指针常量**记作**指针**是一个**常量**的缩写，同理，**常量指针**当作**指向常量的指针**的缩写。

### 如何声明常量指针和指针常量？

```c
const int* a1;
int const *a2;
int* const a3;
```

以上代码演示了 const 的三个位置，分别是在类型前面、在类型和 * 中间、在 * 后面。那么到底**哪个是指针常量，哪个是常量指针？**

1. 只需要关注 const 和 * 的相对位置。
2. const 在 * 之前是常量指针，指向常量的指针。const 在 * 后面是指针常量，指针是一个常量。

再回来看上面的代码，a1 和 a2 的 const 再 * 前面，因此 a1 和 a2 都是常量指针。a3 的 const 在 * 后面，因此 a3 是指针常量。

> 记忆的小技巧：从左往右看，遇到 const 读常量，遇到 * 读指针。因此 `const int* a1;` 是常量指针，`int const *a2;` 也是常量指针，`int* const a3;` 是指针常量。

### 常量指针常量

将常量指针和指针常量混合起来就是常量指针常量，指向常量的指针常量。

```c
const int* const a;
int const * const b;
// a 和 b 都是常量指针常量
```

我们依旧用小技巧来读，常量(const)指针(*)常量(const)。

## 复杂指针类型

```c
int p;    
// 这是一个普通的整型变量  

int *p;   
// 首先从p处开始,先与*结合,说明p是一个指针；
// 然后再与int结合,说明指针所指向的内容的类型为int型.
// 所以p是一个返回整型数据的指针  
      
int p[3];   
// 首先从p处开始,先与[]结合,说明p是一个数组;
// 然后与int结合,说明数组里的元素是整型的.
// 所以p是一个由整型数据组成的数组 
      
int *p[3]; // 指针数组
// 首先从p处开始,先与[]结合,因为其优先级比*高,所以p是一个数组;
// 然后再与*结合,说明数组里的元素是指针类型;
// 然后再与int结合,说明指针所指向的内容的类型是整型的;
// 所以P 是一个由返回整型数据的指针所组成的数组  

int (*p)[3]; // 数组指针
// 首先从p处开始,先与*结合,说明p是一个指针;
// 然后再与[]结合,说明指针所指向的内容是一个数组;
// 然后再与int结合,说明数组里的元素是整型的;
// 所以p是一个指向由整型数据组成的数组的指针

int **p; 
// 首先从p开始,先与*结合,说是p是一个指针;
// 然后再与*结合,说明指针所指向的元素是指针;
// 然后再与int结合,说明该指针所指向的元素是整型数据.
// 由于二级指针以及更高级的指针极少用在复杂的类型中,
// 所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针. 
 
int p(int); 
//从p处起,先与()结合,说明p是一个函数;
// 然后进入()里分析,说明该函数有一个整型变量的参数;
// 然后再与外面的int结合,说明函数的返回值是一个整型数据.

int (*p)(int); 
// 从p处开始,先与指针结合,说明p是一个指针;
// 然后与()结合,说明指针指向的是一个函数;
// 然后再与()里的int结合,说明函数有一个int型的参数;
// 再与最外层的int结合,说明函数的返回类型是整型;
// 所以p是一个指向有一个整型参数且返回类型为整型的函数的指针.
  
int *(*p(int))[3]; 
//可以先跳过,不看这个类型,过于复杂.
// 从p开始,先与()结合,说明p是一个函数;
// 然后进入()里面,与int结合,说明函数有一个整型变量参数;
// 然后再与外面的*结合,说明函数返回的是一个指针;
// 然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组;
// 然后再与*结合,说明数组里的元素是指针;
// 然后再与int结合,说明指针指向的内容是整型数据.
// 所以p是一个参数为一个整数且返回一个指向由 整型指针变量组成的数组 的指针变量的函数.
```

> PS：函数指针是在结构体哪里讲解，目前了解即可。

## 指针和多维数组

**指针和多维数组有什么关系？为什么要了解它们的关系？**处理多维数组的函数要用到指针，所以在使用这种函数之前，先要更深入地学习指针。

### 指针和多维数组的关系

```c
int zippo[4][2]; /* 内含int数组的数组 */
```

数组名 zippo 是该数组首元素的地址。在本例中，zippo 的首元素是一个内含两个 int 值的数组，所以 zippo 是这个内含两个 int 值的数组的地址。



下面，我们从指针的属性进一步分析。

因为 zippo 是数组首元素的地址，所以 zippo 的值和 &zippo\[0] 的值相同。而 zippo\[0] 本身是一个内含两个整数的数组，所以 zippo\[0] 的值和它首元素（一个整数）的地址（即&zippo\[0]\[0]的值）相同。

简而言之，zippo\[0] 是一个占用一个 int 大小对象的地址，而 zippo 是一个占用两个 int 大小对象的地址。由于这个整数和内含两个整数的数组都开始于同一个地址，所以 zippo 和 zippo\[0] 的值相同。 

给指针或地址加 1，其值会增加对应类型大小的数值。在这方面，zippo 和 zippo\[0] 不同，因为 zippo 指向的对象占用了两个 int 大小，而 zippo\[0] 指向的对象只占用一个 int 大小。因此， zippo + 1 和 zippo\[0] + 1 的值不同。 

解引用一个指针（在指针前使用 \* 运算符）或在数组名后使用带下标的 \[] 运算符，得到引用对象代表的值。因为 zippo\[0] 是该数组首元素（zippo\[0]\[0]）的地址，所以 \*(zippo\[0]) 表示储存在 zippo\[0]\[0] 上的值（即一个 int 类型的值）。与此类似，\*zippo 代表该数组首元素（zippo\[0]）的值，但是 zippo\[0] 本身是一个 int 类型值的地址。该值的地址是 &zippo\[0]\[0]，所以 \*zippo 就是 &zippo\[0]\[0]。对两个表达式应用解引用运算符表明， \*\*zippo 与 \*&zippo\[0]\[0] 等价，这相当于 zippo\[0]\[0]，即一个 int 类型的值。

简而言之， zippo 是地址的地址，必须解引用两次才能获得原始值。地址的地址或指针的指针是就是双重间接（double indirection）的例子。 

显然，增加数组维数会增加指针的复杂度。现在，大部分初学者都开始意识到指针为什么是 C 语言中最难的部分。

```c
int zippo[4][2] = { { 2, 4 }, { 6, 8 }, { 1, 3 }, { 5, 7 } }; 
printf(" zippo = %p, zippo + 1 = %p\n",zippo, zippo + 1);
printf("zippo[0] = %p, zippo[0] + 1 = %p\n",zippo[0], zippo[0] + 1); 
printf(" *zippo = %p, *zippo + 1 = %p\n",*zippo, *zippo + 1); 
printf("zippo[0][0] = %d\n", zippo[0][0]); 
printf(" *zippo[0] = %d\n", *zippo[0]); 
printf(" **zippo = %d\n", **zippo); 
printf(" zippo[2][1] = %d\n", zippo[2][1]); 
printf("*(*(zippo+2) + 1) = %d\n", *(*(zippo + 2) + 1));
// 结果
zippo = 0x0064fd38, zippo + 1 = 0x0064fd40 
zippo[0]= 0x0064fd38, zippo[0] + 1 = 0x0064fd3c 
*zippo = 0x0064fd38, *zippo + 1 = 0x0064fd3c 
zippo[0][0] = 2 
*zippo[0] = 2 
**zippo = 2 
zippo[2][1] = 3 
*(*(zippo+2) + 1) = 3 
```

要特别注意，与 zippo\[2]\[1] 等价的指针表示法是 \*(\*(zippo+2) + 1)。看上去比较复杂，应最好能理解。下面列出了理解该表达式的思路：

![](E:\Note\Code Language\the-c\picture\basic\5-6.png)

![](E:\Note\Code Language\the-c\picture\basic\5-7.png)

### 指向二维数组的指针

声明一个指向二维数组的指针使用的是数组指针。

```c
int (* pz)[2];
```

### 指针的兼容性

指针之间的赋值比数值类型之间的赋值要严格。例如，不用类型转换就可以把 int 类型的值赋给 double 类型的变量，但是两个类型的指针不能这样做。

```c
int (*pa)[2];
int (*pb)[3];
int ar[3][2];
int **p; // 一个指向指针的指针

pa = ar; // 有效都是指向内含2个int类型元素数组的指针
pb = ar; // 无效
p  = ar; // 无效
*p = ar[0]; // 有效
```

### 形参是二维数组的函数的声明

以 arr[2][3] 作为实参为例，支持下面两种形参是二维数组的函数声明和定义。

```c
int f(int (*ar)[3]);
int f(int ar[][3]);
```

**注意，数组的列数是必须和实参一致的，不能省略。**这一点十分重要，因为列数向函数传递了必须的信息。



刚开始学的时候，可能会疑惑为什么 int\*\* ar 不能来接收二维数组。下面来讲解一下 **int\*\* ar 和 int (\*ptr)[3] 有什么差别**？这主要是由于指针加法的问题。这涉及到编译器如何对一个指针进行加法操作了。因此，我们先看一下指针怎么进行加法的。

以 int* ptr 为例，ptr + 3，编译器会先从 ptr 中读取地址，然后判断这个指针的类型是 int 类型，才知道对 ptr + 3 应该是加三个 int 的长度，即地址加 3*4 个字节。



总结一下，编译器对指针的加法操作：1. 获取指针变量指向的地址；2. 获取指针类型，计算该指针指向的类型的内存大小；3. 计算加法操作之后的地址。



如此，我们再回来看一下 int\*\* ar 指针，对它进行 +1 操作的过程：1. 获取 ar 指针指向的地址；2. 指针指向的类型是 int\*(int\* 在 32 位系统中是 4 字节，64 位系统中是 8 字节，这里我们假设是 64 位系统)，占据的内存大小是 8 字节；3. 对 ar + 1 就是在 ar 指向的地址的基础上加 1\*8 个字节。

而 int (\*ptr)[3] 的加法：ptr+1 的过程：1. 获取 ptr 的地址；2. ptr 的类型是含有三个元素的数组，数组的元素是 int，因此 ptr 指向的类型占据的内存大小是 3 个 int 类型的大小，即 12 个字节；3. 对 ptr + 1 就是在 ptr 指向的地址的基础上加 1*12 个字节。

```c
#include<stdio.h>
int f(int **a);
int main()
{
    int a[2][3] = {{1, 7, 8},{2, 3, 4}};
    f(a);
    return 0;
}
int f(int **a)
{
    printf("*(a+1):%d\n", *(a+1));
    return 0;
}
```

输出结果：8。

可以看到 int\*\* ar 的加法操作和二维数组是有区别的，因此用 ar 去接收二维数组在运行时极可能会造成程序的崩溃。所以 int (\*ptr)[3] 中的 [3] 就是为了告诉编译器进行指针加法运算时应该移动的距离。

**一般而言，声明一个指向 N 维数组的指针时，只能省略最左边方括号中的值**：

```c
int sum4d(int ar[][12][20][30], int rows);
```

## 指针、数组、函数

### 指针和数组

学习过指针之后，回忆下我们学过的数组的知识，可以发现指针和数组名都表示地址，它们之间有什么联系和区别吗？

**联系：**指针和数组的联系很紧密，**指针和数组名都是地址**。在学习数组知识的时候，访问数组元素的时候，可以使用指针表示法和数组表示法。

在 C 语言中，数组和指针非常相似，甚至可以互换。可以用指针表示数组，也可以用数组表示指针。比如在函数的参数中，如果传递的是一个数组，可以用一个指针变量来接收。所以对于初学者来说，可以简单的理解为，数组和指针等价。但事实上，数组和指针还是有区别的，这一点我们稍后再说。

我们的系统中，地址按字节编址。在 C 中，指针加 1 指的是增加一个存储单元。对数组而言，这意味着把加 1 后的地址是下一个元素的地址，而不是下一个字节的地址。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节。

![](E:\Note\Code Language\the-c\picture\basic\5-8.png)


**区别**：指针是变量，而数组名是常量。

编译器把数组名识别为该数组首元素地址的别名，因此数组名必须为常量，不然一旦改变数组名的值，就意味着改变了数组的存储位置。那么指针是变量，数组名是常量会有什么差异呢？

**1.赋值问题。** 可以用数组名为指针赋值，但是不能用指针为数组名赋值(常量可以赋值给变量，但是常量不能被赋值)。

```cpp
const char * pt1 = "Something is pointing at me."; 
const char arr1[] = "Something is pointing at me.";
pt1 = arr1; // 正确
arr1 = pt1; // 错误
```

**2.自增自减操作。** 指针可以进行自增自减操作，数组名不可以。因为数组名是常量，对数组名进行自增操作，就像是 `3++` 是错误的语法。

```cpp
const char * pt1 = "Something is pointing at me."; 
const char arr1[] = "Something is pointing at me.";
pt1++; // 正确
arr1++; // 错误。
```

**3.内存大小。** 数组会占用 `元素个数 * 元素类型的内存大小` 的空间，而指针只会占据一个指针变量的空间。

> PS：指针变量的存储大小是由编译器决定的，而不是它指向的数据类型决定的。指针变量在 32 位编译器中是占 4 字节(32 位)，在 64 位编译器中是占 8 字节(64 位)。可以根据这一特点判断使用的编译器是多少位的。


例如，下面的两个字符串变量，由于字符串字面量会被保存在内存中，pt1 只是指向了该字符串字面量的首地址，而 arr1 则是申请到了一块内存区域来保存这个字符串的副本。这意味着**使用指针的时候，内存中只存有一个该字符串；而使用数组时，内存中会存在两个该字符串**。

```cpp
const char * pt1 = "Something is pointing at me."; 
const char arr1[] = "Something is pointing at me.";
printf("sizeof(pt1):%d\n", sizeof(pt1));
printf("sizeof(arr1):%d\n", sizeof(arr1));
```

<img src="E:\Note\Code Language\the-c\picture\basic\5-9.png" align="left" />

**4.二维数组。** 规则矩形和不规则矩形。

```cpp
int arr1[] = {1, 2, 3};
int arr2[] = {5, 7};
int arr3[] = {3, 2, 8, 9};
int arr4[] = {2};
int arr5[] = {1, 8};

int *pt[5] = {arr1, arr2, arr3, arr5, arr5};
int arr[5][5] = {{1, 2, 3}, {5, 7}, {3, 2, 8, 9}, {2}, {1, 8}};
```

pt 可以看作不规则的矩阵二维数组，每行长度不同；而 arr 则看作规则的二维数组，每行长度都是 5。

```cpp
// pt
1 2 3
5 7
3 2 8 9
2
1 8

// arr
1 2 3 0 0
5 7 0 0 0
3 2 8 9 0
2 0 0 0 0
1 8 0 0 0
```

### 指针和函数

学习过指针之后，我们就可以来看看地址传递参数的本质了。在讲函数参数传递机制的时候，我们提到了地址传递，当时用到的程序是交换函数的两个参数的值，代码如下：

```c
#include<stdio.h>
int swap(int *a, int *b);
int main()
{
    int a = 30, b = 24;
    printf("main 交换前：a=%d, b=%d\n", a, b);
    swap(&a, &b);
    printf("main 交换后：a=%d, b=%d\n", a, b);
 
    return 0;
}
int swap(int *x, int *y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
}
```

在学习指针之后，能够看出来 swap 函数中的参数实际上就是一个指针变量。传递的 &a 和 &b 是变量 a 和 b 的地址。在地址传递中，我提到过其本质依旧是值传递，在学习过指针之后，我们可以来看看为什么会这么说了。我们对上面的代码进行一下小修改。

```c
#include<stdio.h>
int swap(int *a, int *b);
int main()
{
    int a = 30, b = 24;
    printf("main：&a=%p, &b=%p\n", &a, &b);
    int* ptr1 = &a;
    int* ptr2 = &b;
    printf("main：&ptr1=%p, &ptr2=%p\n", &ptr1, &ptr2);
    printf("main：ptr1=%p, ptr2=%p\n", ptr1, ptr2);
    printf("main：*ptr1=%d, *ptr2=%d\n", *ptr1, *ptr2);
    printf("main 交换前：a=%d, b=%d\n", a, b);
    swap(ptr1, ptr2);
    printf("main 交换后：a=%d, b=%d\n", a, b);

    return 0;
}
int swap(int *x, int *y)
{
    printf("swap：&x=%p, &y=%p\n", &x, &y);
    printf("swap：x=%p, y=%p\n", x, y);
    printf("swap：*x=%d, *y=%d\n", *x, *y);
    int temp = *x;
    *x = *y;
    *y = temp;
}
```

![](E:\Note\Code Language\the-c\picture\basic\5-10.png)

整型变量 a 的地址是 0x61FE1C，整型变量 b 的地址是 0x61FE18。

main 函数中指针变量 ptr1 的地址是 0x61FE10，存储的值是整型变量 a 的地址 0x61FE1C；指针变量 ptr2 的地址是 0x61FE08，存储的值是整型变量 b 的地址 0x61FE18。

swap 函数中的指针变量 x 的地址是 0x61FDE0，存储的值是整型变量 a 的地址 0x61FE1C；指针变量 y 的地址是 0x61FDE8，存储的值是整型变量 b 的地址 0x61FE18。

**这说明什么？**这说明 main 函数中调用 swap 函数时传递参数 ptr1 和 ptr2，其实依旧是传递的 ptr1 和 ptr2 的值，也就是整型变量 a 和 b 的地址，并用这个值去初始化了 swap 中的形式参数 —— 指针变量 x 和 y。所以本质上地址传递依旧是值传递。


**指针与函数可以有以下的联系**：

1. **在函数间传递信息**。如果希望在被调函数中改变主调函数的变量，参数必须使用指针。

2. **处理参数是数组的函数**。通常函数的参数都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针。但是对于数组别无选择，必须传递指针，因为这样做效率高。如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字 const。

   >  **PS**：这样使用 const 并不是要求原数组是常量，而是该函数在处理数组时将其视为常量，不可更改。

3. **函数也可以有指针**，事实上函数名本身就代表着地址，使用函数指针可以在结构体中定义函数。

### 指针和结构体

这一部分内容主要是放在结构体的知识中，所以这部分内容目前不需要记住。使用指针访问结构体的成员变量有两种方法：

```c
Struct {
    int a;
    double b;
} *ptr;

int main(void)
{
 	(*ptr).b; // 第一种方法
    ptr->a;   // 第二种方法
}
```

## 函数指针

### 函数指针的用途

C 语言指针除了可以指向变量之外，还可以声明指向函数的指针，这种指针被称为函数指针。**这个复杂的东西到底有何用处**？

1. 函数指针可以作为另一个函数的参数，告诉该函数要使用哪一个函数。例如，回调函数就是用函数指针。
2. 函数指针可以作为结构体的成员。在结构体中不能直接声明函数，但是可以声明函数指针。这样就可以用结构体替代 C++ 中的类，这也体现了面向对象是一种思想，而不是语言，因为使用 C 语言一样可以实现面向对象编程。

这里主要介绍函数指针的第一种用法 —— 作为函数的参数。**用函数指针作为函数的参数有什么好处**？**A**：可以抽象出更通用的函数，通过传递函数指针来实现不同的效果。比较经典的函数指针作为函数参数的例子 —— C 库的 qsort() 函数：

```c
// <stdlib.h> 中 qsort() 函数原型:
void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))
```

排序数组涉及比较两个元素，以确定先后。如果元素是数字，可以使用 > 运算符；如果元素是字符串或结构，就要调用函数进行比较。C 库中的 qsort() 函数可以处理任意类型的数组，但是要告诉 qsort() 使用哪个函数来比较元素。为此， qsort() 函数的参数列表中，有一个参数接受指向函数的指针。然后，qsort() 函数使用该函数提供的方案进行排序，无论这个数组中的元素是整数、字符串还是结构。下面演示一下使用 函数指针作为参数的 qsort() 函数的灵活性：

```c
#include<stdio.h>
#include<stdlib.h>
int compare_int1(const void* a, const void* b)
{
    int *c = (int*) a;
    int *d = (int*) b;
    return *c - *d;
}
int compare_int2(const void* a, const void* b)
{
    int *c = (int*) a;
    int *d = (int*) b;
    return *d - *c;
}
void print_arr(int arr[], size_t num)
{
    for(int i = 0; i < num; i++)
        printf("%d ", arr[i]);
    printf("\n");
}
int main()
{
    int a[10] = {35, 12, 55, 27, 34, 59, 94, 0, 25, 87};
    printf("排序前 a 数组：");
    print_arr(a, 10);
    printf("-----------------------\n");
    qsort(a, 10, sizeof(a[0]), compare_int1);   
    printf("----- 从小到大排序 -----\n");
    printf("排序后 a 数组：");
    print_arr(a, 10);
    printf("-----------------------\n");
    printf("----- 从大到小排序 -----\n");
    printf("排序后 a 数组：");
    qsort(a, 10, sizeof(a[0]), compare_int2);
    print_arr(a, 10);
    return 0;
}
// 结果：
排序前 a 数组：35 12 55 27 34 59 94 0 25 87 
-----------------------
----- 从小到大排序 -----
排序后 a 数组：0 12 25 27 34 35 55 59 87 94
-----------------------
----- 从大到小排序 -----
排序后 a 数组：94 87 59 55 35 34 27 25 12 0
```

可以看到，通过传递不同的函数可以让 qsort() 函数分别实现从小到大排序和从大到小排序的效果，这样不需要我们分别创建两个排序函数，大大减少代码量。除了基本数据类型的排序，也可以通过传递函数指针的方式让 sqort() 函数对字符串数组、结构体数组进行排序，而且我们可以自定义按照什么规则进行排序。

> PS：学过 Java 的朋友应该会比较熟悉，在 Java 中是用过 Comparator 接口来传递比较规则的，Comparator 接口中只有一个 compare() 函数，实际上也就是传递了一个函数指针。

### 函数指针的定义

前面我们已经了解过了使用函数指针的优点，下面我们就开始学习函数指针的知识吧。

回顾下我们之前学习的指针。假设有一个指向 int 类型变量的指针，该指针储存着这个 int 类型变量储存在内存位置的地址。同样，函数也有地址，因为函数的机器语言实现由载入内存的代码组成。指向函数的指针中储存着函数代码的起始处的地址。 

声明一个数据指针时，必须声明指针所指向的数据类型。同样的，**声明一个函数指针时，必须声明指针指向的函数类型**，即函数的**返回类型和形参类型**。

例如，考虑下面的函数原型： 

```c
void ToUpper(char *); // 把字符串中的字符转换成大写字符 
```

ToUpper() 函数的类型是“带 char * 类型参数、返回类型是 void 的函数”。下面声明了一个指针 pf 指向该函数类型： 

```c
void (*pf)(char *); // pf 是一个指向函数的指针 
```

从该声明可以看出，第1对圆括号把 * 和 pf 括起来，表明 pf 是一个指向函数的指针。因此，(*pf) 是一个参数列表为 char *、返回类型为 void 的函数。 

**注意**：把函数名 ToUpper 替换为表达式 (\*pf) 是创建指向函数指针最简单的方式。所以，如果想声明一个指向某类型函数的指针，可以写出该函数的原型后把函数名替换成 (\*pf) 形式的表达式，创建函数指针声明。前面提到过，由于运算符优先级的规则，在声明函数指针时必须把 \* 和指针名括起来。如果省略第1个圆括号会导致完全不同的情况：

```c
void *pf(char *); // pf 是一个返回void指针的函数
```

### 函数指针的赋值

声明了函数指针后，可以把类型匹配的函数地址赋给它：

1. 1. 直接用函数名为函数指针赋值；
   2. 用(&函数名)为函数指针赋值。

例如：

```c
void ToUpper(char *); // 函数
int round(double); // 函数

void (pf)(char*); // 函数指针
int main(void) {
    pf = ToUpper; // 正确
    pf = &ToUpper; // 正确
    pf = ToUpper(); // 错误，这是调用函数。
    pf = round; // 错误，round和指针类型不匹配。
}
```

### 函数指针的调用

给函数指针赋值时有两种写法，同样，使用函数组指针也同样有两种对应的写法。

```c
void ToUpper(char *); // 函数
void (pf)(char*); // 函数指针
int main(void) {
    pf = ToUpper;
    char str[] = "hello";
    pf(str); // 正确
    (*pf)(str); // 正确
}
```

之所以有两种写法是由于历史的原因，贝尔实验室的 C 和 UNIX 的开发者采用第1种形式，而伯克利的 UNIX 推广者却采用第2种形式。K&R C 不允许第2种形式。但是，为了与现有代码兼容，ANSI C 认为这两种形式等价。后续的标准也延续了这种矛盾的和谐。