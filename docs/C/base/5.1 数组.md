---
lang: zh-CN
title: 数组
description: 数组
categories:
 - C语言
tags:
 - C语言
---

## 数组

### 什么是数组？

之前其实已经简单介绍过字符数组和字符串的概念，事实上，在 C 语言中不只能创建 char 类型数组，还可以创建其他类型的数组。

**数组由数据类型相同的一系列元素组成**。需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型，编译器根据这些信息正确地创建数组。普通变量可以使用的类型，数组元素都可以用。

数组在内存中是连续的存储单元，可以把数组看作是一行连续的多个存储单元。

我们在学习普通变量的时候学习了普通变量的定义、初始化、使用，而数组的知识同样需要学习如何定义一个数组，如何初始化一个数组，以及数组的使用。

### 定义一维数组

在使用一个变量之前需要先定义该变量，同样的，在使用数组之前需要先定义数组。编译器会根据定义的数组在内存中找到一块连续的存储单元来存储数组的数据。

数组定义的格式：

```c
type arrayName [arraySize];
```

这叫做一维数组，事实上我们平常说的数组都是指一维数组，需要注意的是：

1. type 可以是任意有效的 C 数据类型。
2. arrayName 被称为数组名，其命名规则满足 C 语言的命名标准，它代表着数组的起始地址。
3. arraySize 必须是一个大于零的整数常量。在 C99 标准之前，arraySize 不允许是变量，C99 标准之后引入了变长数组的概念。

定义数组的演示：

```c
float candy[365]; /* 内含365个float类型元素的数组 */ 
char code[12];    /* 内含12个char类型元素的数组*/ 
int states[50];   /* 内含50个int类型元素的数组*/
```

要访问数组中的元素，通过使用数组下标数(也称为索引)表示数组中的各元素。数组元素的编号从 0 开始，所以 candy[0] 表示 candy 数组的第 1 个元素，candy[364] 表示第 365 个元素，也就是最后一个元素。

### 数组的初始化

#### 数组的通用初始化

数组通常被用来储存程序需要的数据。例如，一个内含 12 个整数元素的数组可以储存 12 个月的天数。在这种情况下，在程序一开始就初始化数组比较好。下面介绍初始化数组的方法。 

在学习数组之前，我们接触到的变量都是**只能存储单个值的，称为标量变量**。我们已经很熟悉如何初始化这类变量：

```c
int a = 10;
double b = 1.9;
```

下面来了解下数组的初始化，和标量变量的初始化一样，**数组初始化指在数组定义时给数组元素赋予初值**。C 语言使用新的语法来初始化数组。

```c
type arrayName [arraySize] = {value1, value2, ..., valueN};
```

例如：

```c
int powers[8] = {1, 2, 4, 6, 8, 16, 32, 64};
```

如上所示，用以逗号分隔的值列表(用花括号括起来)来初始化数组，各值之间用逗号分隔。在逗号和值之间可以使用空格。根据上面的初始化，把 1 赋给数组的首元素(powers[0])，以此类推。

数组初始化的限制：

1. **只有在定义数组时才可以初始化，此后就不能再用了**。
2. **不能直接将一个数组赋值给另一个数组**。

初始化注意事项：

1. **使用数组之前必须先初始化数组或者为每个元素赋值，否则编译器使用的值是内存相应位置上的现有值**。(PS：事实上，这一条只针对自动存储类别的数组，对于静态存储期的数组，即使没有初始化，编译器会默认将所有元素初始化为 0。这一部分是存储类别的知识，目前不需要记住。)
2. **初始化列表的项数和数组的大小不一致。**
   a. **初始化列表的项数大于数组的大小，编译器报错。**
   b. **初始化列表的项数小于数组的大小，编译器将剩余的元素初始化为 0。**也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；但是，如果部分初始化数组，剩余的元素就会被初始化为0。
3. 根据第2点，**可以省略方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数**。但必须保证初始化列表中的项数是正确的，否则即使少了一项或者多了一项，编译器都不会察觉。
    ```c
    int a [10]= {}; // 将 a 数组的十个元素都初始化为 0.
    ```
4. **如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小**。
   
    ```c
    int a[] = { 1, 2, 3, 4, 5, 6};// 编译器初始化一个含有6个元素的数组
    ```
5. 使用 **const** 声明数组。有时需要把数组设置为只读，这样程序只能从数组中检索值，不能把新值写入数组。要创建只读数组，应该用 const 声明和初始化数组。例如：

    ```c
    const int days[MONTHS] = {31,28,31,30,31,30,31,31,30,31,30,31}; 
    ```

这样程序在运行过程中就不能修改该数组中的内容。和普通变量一样，应该使用声明来初始化 const 数据，因为一旦声明为 const，便不能再给它赋值。

#### 字符串初始化(字符串特有)

还有一种初始化数组的方法，这种方法仅限于初始化字符数组，更确切地说是仅限于字符串初始化 —— 使用字符串常量初始化。

```c
char str1[10] = "hello";  // 数组长度是 10
char str2[10] = {"world"};// 数组长度是 10
char str3[] = "hello";    // 数组长度是 6
char str4[] = {"world"};  // 数组长度是 6
```

#### 指定初始化器(C99新特性)

C99 增加了一个新特性：指定初始化器（designated initializer）。利用该特性可以初始化指定的数组元素。例如，只初始化数组中的最后一个元素。

对于传统的 C 初始化语法，必须初始化最后一个元素之前的所有元素，才能初始化它： 

```c
int arr[6] = {0,0,0,0,0,212}; // 传统的语法
```

而C99规定，**可以在初始化列表中使用带方括号的下标指明待初始化的元素**：

```c
int arr[6] = {[5] = 212}; // 把arr[5]初始化为212 
```

下面我们来**演示一下指定初始化器的用法**：

```c
int days[12] = { 31, 28, [4] = 31, 30, 31, [1] = 29 };
// days 数组：days[] = { 31, 29, 0, 0, 31, 30, 31, 0, 0, 0, 0, 0};
```

这里演示了指定初始化器的两个重要特性。

1. 如果指定初始化器后面有更多的值，如该例中的初始化列表中的片段：`[4] = 31,30,31`，那么后面这些值将被用于初始化指定元素后面的元素，即，在 days[4] 被初始化为 31 后，days[5] 和 days[6] 将分别被初始化为 30 和 31。
2. 如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。如该例中，初始化列表开始时把days[1] 初始化为 28，但是 days[1] 又被后面的指定初始化 [1] = 29 初始化为 29。

**如果未指定数组元素大小会怎样？**

```c
int stuff[] = {1, [6] = 23}; //会发生什么？ 
int staff[] = {1, [6] = 4, 9, 10}; //会发生什么？
```

**编译器会把数组的大小设置为足够装得下初始化的值**。所以，stuff 数组有 7 个元素，编号为 0～6；而 staff 数组的元素比 stuff 数组多两个（即有9个元素）。

### 数组的使用

#### 对数组元素的访问

访问数组元素可以**使用数组表示法和指针表示法**，由于此时还没有学习指针的相关知识，因此这里只介绍数组表示法。数组表示法使用下标(或者称为索引)来访问数组元素的。使用的格式：`数组名[下标]`。

> **注意**：下标从 0 开始计数。这意味着对于一个数组元素个数为 n 的数组来说，其下标的取值范围为[0, n-1]，其中 0 表示数组的第一个元素，1 表示数组的第二个元素，...，n-1 表示数组的最后一个元素。

```c
int m[10] = {1, 2, 3, 4, [8]=9, 33, 2};// 1, 2, 3, 4, 0, 0, 0, 9, 33, 2.
int a = m[7]; // a的值是m数组的第8个元素，即9.
int b = m[4]; // b的值是m数组的第5个元素，即0.
```

在使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是有效的值。例如，假设有下面的声明： `int doofi[20]; `。那么在使用该数组时，要确保程序中使用的数组下标在 0～19的范围内，因为编译器不会检查数组下标是否使用得当（但是，一些编译器发出警告，然后继续编译程序）。在 C 标准中，使用越界下标的结果是未定义的。这意味着程序看上去可以运行，但是运行结果很奇怪，或异常中止。

**C 语言为何会允许这种麻烦事发生？**这要归功于 C 信任程序员的原则。不检查边界，C 程序可以运行更快。编译器没必要捕获所有的下标错误，因为在程序运行之前，数组的下标值可能尚未确定。因此，为安全起见，编译器必须在运行时添加额外代码检查数组的每个下标值，这会降低程序的运行速度。C 相信程序员能编写正确的代码，这样的程序运行速度更快。但并不是所有的程序员都能做到这一点，所以就出现了下标越界的问题。

#### 对数组元素的赋值

在数组定义之后就不能再初始化数组了，但我们可以在声明数组后，借助数组下标(或索引)给数组元素赋值。

```c
#include <stdio.h> 
#define SIZE 50 
int main(void) 
{
    int counter, evens[SIZE]; 
    for (counter = 0; counter < SIZE; counter++) 
        evens[counter] = 2 * counter; 
    ... 
}
```

注意这段代码中使用循环给数组的元素依次赋值。只有初始化才可以对数组整体进行赋值，之后想要修改数组中元素的值只能通过赋值方式依次对需要修改的数组元素赋值。

**C 不允许把数组作为一个单元赋给另一个数组**，**除初始化以外也不允许使用花括号列表的形式赋值**。

```c
int oxen[5] = {5,3,2,8}; /* 初始化没问题 */ 
int yaks[5] = oxen;      /* 不允许 */ 
yaks[5] = oxen[5];       /* 数组下标越界 */
yaks[5] = {5,3,2,8};     /* 不起作用 */
```

#### 数组的大小

在 C99 标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整型常量构成的表达式。sizeof 表达式被视为整型常量，但是 const 值不是(这与 C++ 不同)。另外，表达式的值必须大于 0。

而 C99 标准允许使用变量作为数组的大小，这创建了一种新型数组，称为变长数组（variable-length array）或简称 VLA。VLA 有一些限制，例如，**声明 VLA 时不能进行初始化**。

### 数组和函数

假设要编写一个处理数组的函数，该函数返回数组中所有元素之和，待处理的是名为 marbles 的 int 类型数组。

#### 如何声明以及调用使用数组的函数？

记住，数组名是该数组首元素的地址，所以实际参数 marbles 是一个储存 int 类型值的地址，应把它赋给一个指针形式参数，即该形参是一个指向 int 的指针：

```c
int sum(int * ar); // 对应的函数原型
int main() {
    ...
	total = sum(marbles); // 函数调用
    ...
}
```

函数从实参获得了该数组首元素的地址，知道要在该位置上找出一个整数。注意，该参数并未包含数组元素个数的信息。 我们有两种方法让函数获得这一信息。第一种方法是，在函数代码中写上固定的数组大小。另一个比较灵活的方法是把数组大小作为第 2 个参数。还可传递两个指针分别指向数组的起始位置和终止位置。

注意！一定要时刻注意形参是函数的临时变量：

```c
#include<stdio.h>
int f(int* a, int* b);
int main()
{
    int a[] = {2, 3, 4};
    int b[] = {6, 3, 5};
    f(a, b);
    for(int i = 0; i < 3; i++)
        printf("%d ", a[i]);
    printf("\n");
    for(int i = 0; i < 3; i++)
        printf("%d ", *(b+i));
    getchar();
    return 0;
}
int f(int* a, int* b)
{
    b = a;
    return 0;
}
```

上面代码在 f() 中将 b 的地址赋值给 a，但是并不会改变 main 函数中的 a 和 b 数组。

#### 另一种形参表示

关于函数的形参，还有一点要注意。只有在函数原型或函数定义头中， 可以用 int ar[] 代替 int * ar，在其他地方是不可以的。 

```c
int sum1 (int ar[], int n); // 可以
int sum2 (int ar[], int n) { // 可以
    ...
}
int main() {
    int ar[]; // 错误
}
```

**int \*ar 形式和 int ar[] 形式都表示 ar 是一个指向 int 的指针**。但是，int ar[] 只能用于声明形式参数。第 2 种形式(int ar[])只是提醒读者指针 ar 指向的不仅仅一个 int 类型值，还是一个 int 类型数组的元素。

> PS：还可以用 sizeof 运算符来证明 int ar[] 是一个指针而不是数组(怎么证明的，大家可以思考一下，答案在后面)。

因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。只有在这种情况下，C 才会把 int ar[] 和 int * ar 解释成一样。也就是说，ar 是指向 int 的指针。由于函数原型可以省略参数名， 所以下面 4 种原型都是等价的： 

```c
int sum(int *ar, int n); 
int sum(int *, int); 
int sum(int ar[], int n); 
int sum(int [], int);
```

但是，在函数定义中不能省略参数名。下面两种形式的函数定义等价： 

```c
int sum(int *ar, int n) 
{
	// 其他代码已省略 
}
int sum(int ar[], int n); 
{
	//其他代码已省略 
}
```

#### 思考题

```c
#include<stdio.h>
int f(int *a, int b[]);
int main()
{
    int a[] = {2, 3, 4};
    int b[] = {6, 3, 5};
    printf("main:%d\n", sizeof(b));
    f(a, b);
    getchar();
    return 0;
}
int f(int *a, int b[])
{
    printf("f:%d\n", sizeof(b));
    return 0;
}
```

<img src="E:\Note\Code Language\the-c\picture\basic\5-1.png" align="left" />

main 中的 sizeof 计算结果是：数组 b 的元素个数 * 数组 b 的元素类型占的内存大小，是会根据 b 数组的大小而改变的。例如，b 数组的元素个数是 5，则结果是 20。

f 中的 sizeof 计算结果是：指针占据的内存大小，是确定的。64 位系统的指针固定占 8 位，32 位系统的指针固定占 4 位。

### 多维数组

多维数组其实就是二维数组的继续延申，而且在正常项目中，常用的多维数组就是二维数组了，因此下面我们重点介绍一下二维数组的定义、初始化以及使用。

#### 二维数组

我们之前介绍的数组只有一个下标，称为一维数组，其数组元素也称为单下标变量。在实际问题中有很多量是二维的或多维的，因此 C 语言允许构造多维数组。多维数组元素有多个下标，以标识它在数组中的位置，所以也称为多下标变量。

二维数组就是有两个下标的数组，是常用的多维数组，更高维的数组其实使用的并不多。二维数组定义的一般形式：

```c
type array_Name[n][m];
```

> PS：type 是数组元素的类型，array_Name 是数组名，n 和 m 为常量表达式。

```c
float rain[5][12];
```

**应该如何理解这个数组？**

事实上，**C 语言依旧将二维数组识别为一维数组**，只不过数组的元素不再是如 int 类型的变量了，而是一个数组。那么 rain\[5]\[12] 是有 5 个元素的数组，其中每个元素是一个含有 12 个元素的数组，还是有 12 个元素的数组，其中每个元素是一个含有 5 个元素的数组呢？

这个问题在于 [] 这个运算符的结合方向，[] 是自左向右的，因此编译器识别 rain\[5]\[12] 时，会先和 \[5] 结合，认为 rain 是一个含有 5 个元素的数组，然后识别 \[12] 认为 rain 的每一个元素都是一个含有 12 个元素的数组。

根据以上分析可知，rain 的首元素 rain\[0] 是一个内含 12 个 float 类型值的数组。所以，rain\[1]、rain\[2]等也是如此。如果 rain[0] 是一个数组，那么它的首元素就是 rain\[0]\[0]，第 2 个元素是 rain\[0]\[1]，以此类推。简而言之，数组 rain 有 5 个元素，每个元素都是内含 12 个 float 类型元素的数组，rain\[0] 是内含 12 个 float 值的数组，rain\[0]\[0] 是一个 float 类型的值。假设要访问位于 2 行 3 列的值，则使用 rain\[2]\[3]（记住，数组元素的编号从 0 开始，所以 2 行指的是第 3 行）。

这里对于二维数组，我们往往会采用数学上的行和列来描述，行指的是第一个[]，列指的是第二个[]。这也是因为用二维视图有助于理解二维数组的两个下标。

![](E:\Note\Code Language\the-c\picture\basic\5-2.png)

#### 二维数组初始化

初始化二维数组是建立在初始化一维数组的基础上。首先，初始化一维数组如下： 

```c
sometype ar1[5] = {val1, val2, val3, val4, val5}; 
```

这里，val1、val2 等表示 sometype 类型的值。例如，如果 sometype 是 int，那么 val1 可能是 7；如果 sometype 是 double，那么 val1 可能是 11.34，诸如此类。

```c
int arr1[3][4];
```

如上所示的 arr1 是一个内含 3 个元素的数组，每个元素又是内含 4 个 int 类型元素的数组。所以，对 arr1 而言，val1 应该包含 4 个值，用于初始化内含 4 个 int 类型元素的一维数组。也就是说，因此，为了初始化二维数组 arr1，要用逗号分隔 3 个这样的数值列表：

```c
int arr1[3][4] = {{1, 1, 2, 3}, {2, 4, 5, 3}, {3, 4, 5, 2}};
```

这个初始化使用了 3 个数值列表，**每个数值列表都用花括号括起来**。第 1 个列表的数据用于初始化数组的第 1 行，第 2 个列表的数据用于初始化数组的第 2 行，以此类推。

前面讨论的**数据个数和数组大小不匹配的问题同样适用于这里的每一行**。也就是说，如果第 1 个列表中只有 2 个数，则只会初始化数组第 1 行的前两个元素，而后两个元素将被默认初始化为 0。如果某列表中的数值个数超出了数组每行的元素个数，则会出错，但是这并不会影响其他行的初始化。

> PS：做牛客上的题时，有遇到一个题说初始化二维数组时，{} 中没有任何元素会报错，实践之后发现是可以正确执行的，而且没有任何资料说 {} 是错误的。

**初始化时也可省略内部的花括号，只保留最外面的一对花括号**。只要保证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为0。

这两种初始化的区别：

![](E:\Note\Code Language\the-c\picture\basic\5-3.png)

#### 二维数组的使用

二维数组和一维数组相同，有数组表示法和指针表示法，其中指针表示法在指针处讲解。数组表示法和一维数组类似。

```c
array[4][6]; // array 数组第5行第6列的元素
```

#### 其他多维数组

前面讨论的二维数组的相关内容都适用于三维数组或更多维的数组。可以这样声明一个三维数组： 

```c
int box[10][20][30]; 
```

可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数组想象成一叠数据表。例如，把上面声明的三维数组 box 想象成由 10 个二维数组（每个二维数组都是20行30列）堆叠起来。


还有一种理解 box 的方法是，把 box 看作数组的数组。

也就是说，box 内含 10 个元素，每个元素是内含 20 个元素的数组，这 20 个数组元素中的每个元素是内含 30 个元素的数组。或者，可以简单地根据所需的下标值去理解数组。


通常，处理三维数组要使用 3 重嵌套循环，处理四维数组要使用 4 重嵌套循环。对于其他多维数组，以此类推。 